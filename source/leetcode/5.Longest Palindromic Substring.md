### [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

> Given a string S, find the longest palindromic substring in S. <br/>
> You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

题目大意：寻找给定字符串（长度不超过1000）的最长回文子串，回文子串存在且唯一

题目难度：Medium

```java
/**
 * Created by gzdaijie on 16/5/3
 * 回文字符串只有2种形式, abba,aba
 * (1) 遍历字符,查看其左右是否相等, 更新start,end
 * (2) 遍历字符,如果右边与当前字符相等,查看这2个字符的左右是否相等, 更新start,end
 * 若最长回文串长度为K,最坏复杂度为O(K*N)
 */
public class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        int start = 0, end =  0;

        for (int i = 0; i < len; ++i) {
            // 情况1: aba,奇数回文串
            int k = 1;
            while (i - k >= 0 && i + k < len && s.charAt(i - k) == s.charAt(i + k)) ++k;
            if (end - start < 2 * k - 1) {
                start = i - k + 1;
                end = i + k;
            }
            // 情况2: abba,偶数回文串
            k = 0;
            while (i - k >= 0 && i + k + 1 < len && s.charAt(i - k) == s.charAt(i + k + 1)) ++k;
            if (end - start < 2 * k) {
                start = i - k + 1;
                end = i + k + 1;
            }
        }
        return s.substring(start, end);
    }
}
```

```java
/**
 * Created by gzdaijie on 16/5/3
 * 首先所有字符都相同的字符串无论字符多少,都是回文字符串
 * 对于有连续相等的字符的字符串, zxyyyyyyxa,只需找到连续相等的y的第一个和最后一个位置,判断左右即可
 * 遍历时,可直接从第一个y的位置跳到最后一个y下一位
 */
public class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        int max = 0;
        int start = 0;
        int end = 0;

        for (int i = 0; i < len;) {
            int index = this.getFarestSameChar(s, i);
            int dist = this.getDistance(s,i ,index);
            int p = i - dist;
            int q = index + dist;
            if (q - p + 1 > max) {
                start = p;
                end = q;
                max = end - start + 1;
            }
            i = index + 1; // 从i->index的字符都是相等的,因此可以直接跳过
        }
        return s.substring(start, end + 1);

    }

    /**
     * 判断左右是回文字符的个数
     */
    private int getDistance(String s, int start, int end) {
        int len = s.length();
        int dist = 0;

        start -= 1;
        end += 1;
        while (start >= 0 && end < len) {
            if (s.charAt(start) != s.charAt(end)) break;
            --start;
            ++end;
            ++dist;
        }
        return dist;
    }

    /**
     * 连续字符,最远的一个下标
     */
    private int getFarestSameChar(String s, int index) {
        int len = s.length();
        char ch = s.charAt(index);
        for (int i = index + 1; i < len; ++i) {
            if (ch != s.charAt(i))return i - 1;
        }
        return len - 1;
    }
}
```